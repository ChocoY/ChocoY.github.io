<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ChocoY</title>
    <style>

        a{
            color:blueviolet;
        }
        html,body{
            margin:0;
            border:0;
            font-family: 'Courier New';
        }
        body{
        }

        main{
            max-width: 800px;
            margin: 0 auto;
            border: 6px  solid black;
            box-sizing: border-box;
            padding: 0 30px;
            box-shadow: 0 0 5px lightgray;
            text-shadow: 0 0 2px lightgray;
        }

        .stage{
            width: 300px;
            height: 306px;
            display: inline-block;
            background: #f8f8f8;
            border-width: 1px 1px 1px 1px;
            border-style: solid;
            border-color: #e8e8e8;
            padding: 0 10px;
        }
        header,main>section,footer{
            padding: 16px;
        }
        main>section{
            border-top: 4px  solid black;
            border-bottom: 4px  solid black;            
        }
        
        figure{
            margin: 0 auto;
            display: block;
            text-align: center;
        }
        
        footer{            
            font-size: 14px;
            text-align: center;
        }
        body>header{
            border-top: 4px  solid black;
        }
        nav{
            font-size: 20px;
        }
        summary{
            font-size:20px;
        }
        time{
            font-size:10px;
        }
    </style>
</head>
<body>
    <main>
        <header>
            <h1>ChocoY</h1>
            <p>Don't worry, be happy.</p>
        </header>    
        <section>
            <article>
                <h2>Teris</h2>
                <time datatime="2017-11-08 11:00:16+08:00">2017-11-08 11:00:16</time>
                <figure>
                    <h3>← → ↓ ↑ | w s a d | light
                      <input id="theme" type="checkbox" checked="true" onchange="themeChange"/>
                    </h3>
                    <div>
                      <canvas id="stage" class="stage"></canvas>
                    </div>
                    <audio preload="preload" crossorigin="anonumous" id="audio0" data-time="38">
                        <source src="//pic.ibaotu.com/00/38/21/02e888piCKnh.mp3">
                    </audio>
                </figure>
            </article>
        </section>    
        <footer>The past is never dead. It's not even past. -- William Faulkner</footer>
    </main>
    <script>
        const ca = document.getElementById("stage");
        const dpr = window.devicePixelRatio || 1;
        const W = ca.offsetWidth * dpr - 20;
        const H = ca.offsetHeight * dpr;
        ca.width = W;
        ca.height = H;
        const cvs = ca.getContext("2d");
        const debug = false;        
        cvs.lineCap = "square";
        const config = {
          colors: {
            light:{
              bg: "#fff",
              canvasBg:"#fafafa",
              border:"#f0f0f0",
              O: [0,70,65], //[0,70,65] 
              I: [35,70,65],
              Z: [70,70,65],
              S: [105,70,65],
              J: [140,70,65],
              L: [175,70,65],
              T: [200,70,65],
              textColor: "#888",
              lineColor: "#ddd",
              frameColor: "#aaa"
            },
            dark:{
              bg: "#222",
              canvasBg:"#181818",
              border:"#333",
              O: [0,25,30],
              I: [35,25,30],
              Z: [70,25,30],
              S: [105,25,30],
              J: [140,25,30],
              L: [175,25,30],
              T: [200,25,30],
              textColor: "#666",
              lineColor: "#222",
              frameColor: "#333"
            }
          },
          cubeSize: 12,
          fontSize: 1.2,
          font: 'Courier New',
          displayFps: false,
          lineWidth: 1,
          boardHorizontalCubes: 10,
          boardVerticalCubes: 20,
          scoreForLines:[0,10,25,45,60]
        };
        const direction = {
          up: 0,
          right: 1,
          down: 2,
          left: 3
        };
        const BlockType = ["S", "Z", "L", "J", "I", "O", "T"];
        const HIGHSCORE = 'highScore';
        const RID_DELAY = 200;
        
        let colorsTheme = config.colors.light;
        
        let lastFrameTime = 0;
        let fps=0;
        
        let log = x => {
          if (debug) {
            console.log(x);
          }
        };
        
        class Painter {
          constructor(cfg, cvs, board) {
            this.cubeSize = cfg.cubeSize;
            this.lineWidth = cfg.lineWidth;
            this.boardHorizontalCubes = cfg.boardHorizontalCubes;
            this.boardVerticalCubes = cfg.boardVerticalCubes;
            this.boardHeight =
              cfg.boardVerticalCubes * cfg.cubeSize +
              (cfg.boardVerticalCubes + 1) * cfg.lineWidth;
            this.boardWidth =
              cfg.boardHorizontalCubes * cfg.cubeSize +
              (cfg.boardHorizontalCubes + 1) * cfg.lineWidth;
            this.boardTop = Math.floor((H - this.boardHeight) / 2);
            this.boardLeft = 10; //Math.floor((W - this.boardWidth) / 2);
            this.cvs = cvs;
            this.board = board;
          }
          drawBoard() {
            //log('draw board')
            this.cvs.beginPath();
            this.cvs.lineWidth = this.lineWidth;
        
            // horizontal lines
            for (let i = 0; i <= this.boardVerticalCubes; i++) {
              this.cvs.moveTo(
                this.boardLeft,
                this.boardTop + i * (this.cubeSize + this.lineWidth)
              );
              this.cvs.lineTo(
                this.boardLeft + this.boardWidth - this.lineWidth,
                this.boardTop + i * (this.cubeSize + this.lineWidth)
              );
            }
            // vertical lines
            for (let i = 0; i <= this.boardHorizontalCubes; i++) {
              this.cvs.moveTo(
                this.boardLeft + i * (this.cubeSize + this.lineWidth),
                this.boardTop
              );
              this.cvs.lineTo(
                this.boardLeft + i * (this.cubeSize + this.lineWidth),
                this.boardTop + this.boardHeight - this.lineWidth
              );
            }
            this.cvs.strokeStyle = colorsTheme.lineColor;
            this.cvs.stroke();
        
            //frame
            this.cvs.beginPath();
            this.cvs.moveTo(this.boardLeft, this.boardTop);
            this.cvs.lineTo(this.boardLeft + this.boardWidth - 1, this.boardTop);
            this.cvs.lineTo(
              this.boardLeft + this.boardWidth - 1,
              this.boardTop + this.boardHeight - 1
            );
            this.cvs.lineTo(this.boardLeft, this.boardTop + this.boardHeight - 1);
            this.cvs.lineTo(this.boardLeft, this.boardTop);
            this.cvs.strokeStyle = colorsTheme.frameColor;
            this.cvs.stroke();
          }
          drawNextBlock() {
            this.cvs.beginPath();
            this.cvs.lineWidth = this.lineWidth;
            let left = this.boardLeft + this.boardWidth + 2 * this.cubeSize,
              top = this.boardTop,
              horizontalCubes = 4,
              verticalCubes = 4,
              height =
                horizontalCubes * (this.cubeSize + this.lineWidth) + this.lineWidth,
              width = verticalCubes * (this.cubeSize + this.lineWidth) + this.lineWidth;
        
            // horizontal lines
            for (let i = 0; i <= 4; i++) {
              this.cvs.moveTo(left, top + i * (this.cubeSize + this.lineWidth));
              this.cvs.lineTo(
                left + width - this.lineWidth,
                top + i * (this.cubeSize + this.lineWidth)
              );
            }
            // vertical lines
            for (let i = 0; i <= 4; i++) {
              this.cvs.moveTo(left + i * (this.cubeSize + this.lineWidth), top);
              this.cvs.lineTo(
                left + i * (this.cubeSize + this.lineWidth),
                top + height - this.lineWidth
              );
            }
            this.cvs.strokeStyle = colorsTheme.lineColor;
            this.cvs.stroke();
            if (this.board.nextBlock) {
              let nodes = this.board.nextBlock.getNodes(),
                minX = 99,
                minY = 99,
                maxX = 0,
                maxY = 0;
              for (let i in nodes) {
                minX = minX > nodes[i].x ? nodes[i].x : minX;
                maxX = maxX < nodes[i].x ? nodes[i].x : maxX;
                minY = minY > nodes[i].y ? nodes[i].y : minY;
                maxY = maxY < nodes[i].y ? nodes[i].y : maxY;
              }
              for (let i in nodes) {
                nodes[i].x = nodes[i].x - minX + Math.ceil((4 - (maxX - minX + 1)) / 2);
                nodes[i].y = nodes[i].y - minY + Math.ceil((4 - (maxY - minY + 1)) / 2);
                this.drawNode(top, left, this.cubeSize, this.lineWidth, nodes[i]);
              }
            }
          }
        
          drawBlock() {
            //log(`draw block ${this.block.type}`)
            let nodes = [];
            this.board.block.getNodes().forEach(node => nodes.push(node));
            nodes.forEach(node => {
              if (node.y >= 0) {
                this.drawNode(
                  this.boardTop,
                  this.boardLeft,
                  this.cubeSize,
                  this.lineWidth,
                  node
                );
              }
            });
          }
          drawNode(top, left, cubeSize, lineWidth, node) {
            let lineFix = -lineWidth / 2;
            let light = colorsTheme[node.type][2];
            if(this.board.ridLinesTimer[node.y] > 0){
              if(colorsTheme == config.colors.light){
                light+=Math.ceil((Date.now() - this.board.ridLinesTimer[node.y])/5);
              } else {
                light-=Math.ceil((Date.now() - this.board.ridLinesTimer[node.y])/8);
              }
            }
            if(light > 100){
              light = 100;
            }
            this.cvs.strokeStyle = `hsl(${colorsTheme[node.type][0]},${colorsTheme[node.type][1]}%,${light}%)`;
            this.cvs.beginPath();
            this.cvs.rect(left + node.x * (cubeSize + lineWidth) + lineWidth + lineFix+cubeSize/6,
                         top + node.y * (cubeSize + lineWidth) + lineWidth + lineFix+cubeSize/6,cubeSize*2/3,cubeSize*2/3);
            this.cvs.lineWidth = cubeSize/3;    
            this.cvs.stroke();
          }
        
          drawNodes() {
            this.board.nodes.forEach(node => {
              if (node.y >= 0) {
                this.drawNode(
                  this.boardTop,
                  this.boardLeft,
                  this.cubeSize,
                  this.lineWidth,
                  node
                );
              }
            });
          }
          displayFPS() {
              if(!config.displayFps){
                  return;
              }
            let lastTime = lastFrameTime;
            lastFrameTime = Date.now();
            if(Math.floor(lastFrameTime/1000) - Math.floor(lastTime/1000) > 0){
              fps = 1000 / (lastFrameTime - lastTime || 0);      
            }
            this.cvs.fillStyle = colorsTheme.textColor;
            this.cvs.font = config.fontStyle;
            this.cvs.textBaseline = "bottom";
            this.cvs.fillText(
              `FPS: ${Math.floor(fps * 10) / 10}`,
              this.boardLeft,
              this.boardTop - 3
            );
          }
          displayScore() {
            this.cvs.fillStyle = colorsTheme.textColor;
            this.cvs.font = config.fontStyle;
            this.cvs.textBaseline = "bottom";
            this.cvs.fillText(
              `H-SCORE: ${this.board.highScore || 0}`,
              this.boardLeft + this.boardWidth + this.cubeSize * 2,
              this.boardTop + 4 * this.cubeSize + 5 * this.lineWidth + 4 * this.cubeSize
            );
            this.cvs.fillText(
              `SCORE: ${this.board.score || 0}`,
              this.boardLeft + this.boardWidth + this.cubeSize * 2,
              this.boardTop + 4 * this.cubeSize + 5 * this.lineWidth + 6 * this.cubeSize
            );
            this.cvs.fillText(
              `LINES: ${this.board.lines || 0}`,
              this.boardLeft + this.boardWidth + this.cubeSize * 2,
              this.boardTop + 4 * this.cubeSize + 5 * this.lineWidth + 8 * this.cubeSize
            );
            this.cvs.fillText(
              `LEVEL: ${this.board.level || 1}`,
              this.boardLeft + this.boardWidth + this.cubeSize * 2,
              this.boardTop + 4 * this.cubeSize + 5 * this.lineWidth + 10 * this.cubeSize
            );
          }
          draw() {
            this.cvs.clearRect(0, 0, W, H);
            this.drawBoard();
            this.drawBlock();
            this.drawNodes();
            this.drawNextBlock();
            this.displayFPS();
            this.displayScore();
          }
        }
        
        class Board {
          constructor(cfg, cvs) {
            this.boardHorizontalCubes = cfg.boardHorizontalCubes;
            this.boardVerticalCubes = cfg.boardVerticalCubes;
            this.firstMove = true;
            // block
            this.block;
            this.nextBlock;
            // nodes
            this.nodes = [];
        
            //score            
            this.highScore = localStorage.getItem(HIGHSCORE) || 0;
            this.score = 0;
            this.lines = 0;
            this.level = 1;
            this.ridLinesTimer = new Array(config.boardVerticalCubes);
            this.ridLinesTimer.fill(0);
          }
        
          randomBlock() {
            let blockType = BlockType[Math.floor(Math.random() * BlockType.length)];
            switch (blockType) {
              case "O":
                this.nextBlock = new BlockO(
                  this,
                  this.boardHorizontalCubes / 2 - 1,
                  -2
                );
                break;
              case "I":
                this.nextBlock = new BlockI(
                  this,
                  this.boardHorizontalCubes / 2 - 1,
                  -1
                );
                break;
              case "S":
                this.nextBlock = new BlockS(
                  this,
                  this.boardHorizontalCubes / 2 - 1,
                  -2
                );
                break;
              case "Z":
                this.nextBlock = new BlockZ(
                  this,
                  this.boardHorizontalCubes / 2 - 1,
                  -2
                );
                break;
              case "L":
                this.nextBlock = new BlockL(
                  this,
                  this.boardHorizontalCubes / 2 - 1,
                  -2
                );
                break;
              case "J":
                this.nextBlock = new BlockJ(
                  this,
                  this.boardHorizontalCubes / 2 - 1,
                  -2
                );
                break;
              case "T":
                this.nextBlock = new BlockT(
                  this,
                  this.boardHorizontalCubes / 2 - 1,
                  -2
                );
                break;
            }
          }
          addBlock() {
            //log(`add Block \'${blockType}\'`)
            this.block = this.nextBlock;
            this.randomBlock();
            this.firstMove = true;
          }
          settleBlock() {
            this.block.getNodes().forEach(node => {
              if (node.y >= 0) {
                this.nodes.push(node);
              }
            });
            this.ridLine();
            this.addBlock();
          }
          ridLine() {
            let rowCount = new Array(config.boardVerticalCubes);
            rowCount.fill(0);
            this.nodes.forEach(n => {
              rowCount[n.y] += 1;
            });
        
            // score & lines
            let ridLinesCount = 0,
              score = 0;
            let newNodes = new Array();
            let rowsToRemove = new Array(config.boardVerticalCubes);
            let now = Date.now();
            rowCount.forEach((c,index)=>{
              if(c == config.boardHorizontalCubes){
                if(this.ridLinesTimer[index] > 0 && (this.ridLinesTimer[index] + RID_DELAY < now)){
                  rowsToRemove.push(index);
                  ridLinesCount++;
                } else if(this.ridLinesTimer[index] == 0) {
                    this.ridLinesTimer[index] = now;
                }
              }
            });

            this.nodes.forEach(n => {
              if(rowsToRemove.indexOf(n.y) < 0 ){
                newNodes.push(n);
              }
            });

            rowsToRemove.forEach(r =>{
              newNodes.forEach(n=>{
                if(n.y < r){
                  n.y++;
                }
              });
              this.ridLinesTimer[r] = 0
            });

            this.nodes = newNodes;
            this.lines += ridLinesCount;
            this.level = Math.floor(this.lines / 10);
            this.score += config.scoreForLines[ridLinesCount];
            this.highScore = this.score > this.highScore ? this.score : this.highScore;
            localStorage.setItem(HIGHSCORE,this.highScore);
          }
          canMove(d) {
            let nodes = this.block.getNodes();
            for (let i in nodes) {
              let node = nodes[i];
              let x, y;
              switch (d) {
                case direction.left:
                  x = node.x - 1;
                  y = node.y;
                  break;
                case direction.right:
                  x = node.x + 1;
                  y = node.y;
                  break;
                case direction.down:
                  x = node.x;
                  y = node.y + 1;
                  break;
              }
              if (
                x < 0 ||
                x > config.boardHorizontalCubes - 1 ||
                y > config.boardVerticalCubes - 1
              ) {
                return false;
              }
        
              for (let j in this.nodes) {
                let n = this.nodes[j];
                if (n.x == x && n.y == y) {
                  return false;
                }
              }
            }
            return true;
          }
          isEmpty(nodes) {
            for (let i in nodes) {
              let node = nodes[i];
              if (
                node.x < 0 ||
                node.x > this.boardHorizontalCubes - 1 ||
                this.y > this.boardVerticalCubes - 1
              ) {
                return false;
              }
              for (let j in this.nodes) {
                if (this.nodes[j].x == node.x && this.nodes[j].y == node.y) {
                  return false;
                }
              }
            }
            return true;
          }
          moveBlock(d) {
            if (this.canMove(d)) {
              switch (d) {
                case direction.left:
                  this.block.x--;
                  break;
                case direction.right:
                  this.block.x++;
                  break;
                case direction.down:
                  this.block.y++;
                  break;
              }
              this.firstMove = false;
            } else {
              if (this.firstMove) {
                this.nodes = [];
                this.score = 0;
                this.lines = 0;
              }
              if (direction.down == d) {
                this.settleBlock();
                return true;
              }
            }
          }
        }
        
        class Node {
          constructor(x, y, t) {
            this.x = x;
            this.y = y;
            this.type = t;
            this.deadTimer = 0;
          }
        }
        
        class Block {
          constructor(board, x, y) {
            this.board = board;
            this.x = x;
            this.y = y;
            this.direction = direction.up;
          }
          rotateClockwise() {}
          rotateAnticlockwise() {}
          turn(isClockwise) {}
        }
        
        // 0 0 0
        // 0 * 1
        // 0 1 1
        class BlockO extends Block {
          constructor(board, x, y) {
            super(board, x, y);
            this.type = "O";
            this.color = colorsTheme.o;
          }
          getNodes() {
            return [
              new Node(this.x, this.y, this.type),
              new Node(this.x + 1, this.y, this.type),
              new Node(this.x, this.y + 1, this.type),
              new Node(this.x + 1, this.y + 1, this.type)
            ];
          }
        }
        class BlockI extends Block {
          constructor(board, x, y) {
            super(board, x, y);
            this.type = "I";
            this.color = colorsTheme.i;
        
            this.isVertical = true; // true or false horizontal or vertical
          }
          getNodes() {
            if (this.isVertical) {
              return [
                new Node(this.x, this.y, this.type),
                new Node(this.x, this.y - 1, this.type),
                new Node(this.x, this.y - 2, this.type),
                new Node(this.x, this.y - 3, this.type)
              ];
            } else {
              return [
                new Node(this.x, this.y, this.type),
                new Node(this.x - 1, this.y, this.type),
                new Node(this.x - 2, this.y, this.type),
                new Node(this.x + 1, this.y, this.type)
              ];
            }
          }
          turn() {
            let x = this.x,
              y = this.y,
              isVertical = this.isVertical;
            this.isVertical = !this.isVertical;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x + 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x + 2;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x - 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
        
            this.x = x;
            this.y = y;
            this.isVertical = isVertical;
          }
        }
        class BlockS extends Block {
          constructor(board, x, y) {
            super(board, x, y);
            this.type = "S";
            this.color = colorsTheme.s;
        
            this.isVertical = true; // true or false horizontal or vertical
          }
          getNodes() {
            if (this.isVertical) {
              return [
                new Node(this.x - 1, this.y, this.type),
                new Node(this.x - 1, this.y - 1, this.type),
                new Node(this.x, this.y, this.type),
                new Node(this.x, this.y + 1, this.type)
              ];
            } else {
              return [
                new Node(this.x, this.y, this.type),
                new Node(this.x + 1, this.y, this.type),
                new Node(this.x, this.y + 1, this.type),
                new Node(this.x - 1, this.y + 1, this.type)
              ];
            }
          }
          turn() {
            let x = this.x,
              y = this.y,
              isVertical = this.isVertical;
            this.isVertical = !this.isVertical;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x + 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x - 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
        
            this.x = x;
            this.y = y;
            this.isVertical = isVertical;
          }
        }
        class BlockZ extends Block {
          constructor(board, x, y) {
            super(board, x, y);
            this.type = "Z";
            this.color = colorsTheme.z;
        
            this.isVertical = true; // true or false horizontal or vertical
          }
          getNodes() {
            if (this.isVertical) {
              return [
                new Node(this.x, this.y, this.type),
                new Node(this.x + 1, this.y, this.type),
                new Node(this.x + 1, this.y - 1, this.type),
                new Node(this.x, this.y + 1, this.type)
              ];
            } else {
              return [
                new Node(this.x, this.y, this.type),
                new Node(this.x - 1, this.y, this.type),
                new Node(this.x, this.y + 1, this.type),
                new Node(this.x + 1, this.y + 1, this.type)
              ];
            }
          }
          turn() {
            let x = this.x,
              y = this.y,
              isVertical = this.isVertical;
            this.isVertical = !this.isVertical;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x + 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x - 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
        
            this.x = x;
            this.y = y;
            this.isVertical = isVertical;
          }
        }
        class BlockL extends Block {
          constructor(board, x, y) {
            super(board, x, y);
            this.type = "Z";
            this.color = colorsTheme.j;
        
            this.direction = 0; // true or false horizontal or vertical
          }
          getNodes() {
            switch (this.direction) {
              // 0 1 0
              // 0 * 0
              // 0 1 1
              case 0:
                return [
                  new Node(this.x, this.y, this.type),
                  new Node(this.x, this.y - 1, this.type),
                  new Node(this.x, this.y + 1, this.type),
                  new Node(this.x + 1, this.y + 1, this.type)
                ];
              // 0 0 0
              // 1 * 1
              // 1 0 0
              case 1:
                return [
                  new Node(this.x, this.y, this.type),
                  new Node(this.x + 1, this.y, this.type),
                  new Node(this.x - 1, this.y, this.type),
                  new Node(this.x - 1, this.y + 1, this.type)
                ];
              // 1 1 0
              // 0 * 0
              // 0 1 0
              case 2:
                return [
                  new Node(this.x, this.y, this.type),
                  new Node(this.x, this.y - 1, this.type),
                  new Node(this.x - 1, this.y - 1, this.type),
                  new Node(this.x, this.y + 1, this.type)
                ];
              // 0 0 0
              // 0 * 1
              // 1 1 1
              case 3:
                return [
                  new Node(this.x + 1, this.y, this.type),
                  new Node(this.x + 1, this.y + 1, this.type),
                  new Node(this.x, this.y + 1, this.type),
                  new Node(this.x - 1, this.y + 1, this.type)
                ];
            }
          }
          turn(isClockwise) {
            let x = this.x,
              y = this.y,
              direction = this.direction;
            if (isClockwise) {
              this.direction = (this.direction + 3) % 4;
            } else {
              this.direction = (this.direction + 1) % 4;
            }
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x + 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x - 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x;
            this.y = y;
            this.direction = direction;
          }
        }
        class BlockJ extends Block {
          constructor(board, x, y) {
            super(board, x, y);
            this.type = "J";
            this.color = colorsTheme.j;
        
            this.direction = 0; // true or false horizontal or vertical
          }
          getNodes() {
            switch (this.direction) {
              // 0 1 0
              // 0 * 0
              // 1 1 0
              case 0:
                return [
                  new Node(this.x, this.y, this.type),
                  new Node(this.x, this.y - 1, this.type),
                  new Node(this.x, this.y + 1, this.type),
                  new Node(this.x - 1, this.y + 1, this.type)
                ];
              // 0 0 0
              // 1 * 0
              // 1 1 1
              case 1:
                return [
                  new Node(this.x - 1, this.y, this.type),
                  new Node(this.x - 1, this.y + 1, this.type),
                  new Node(this.x, this.y + 1, this.type),
                  new Node(this.x + 1, this.y + 1, this.type)
                ];
              // 0 1 1
              // 0 * 0
              // 0 1 0
              case 2:
                return [
                  new Node(this.x, this.y, this.type),
                  new Node(this.x, this.y - 1, this.type),
                  new Node(this.x + 1, this.y - 1, this.type),
                  new Node(this.x, this.y + 1, this.type)
                ];
              // 0 0 0
              // 1 * 1
              // 0 0 1
              case 3:
                return [
                  new Node(this.x - 1, this.y, this.type),
                  new Node(this.x, this.y, this.type),
                  new Node(this.x + 1, this.y, this.type),
                  new Node(this.x + 1, this.y + 1, this.type)
                ];
            }
          }
          turn(isClockwise) {
            let x = this.x,
              y = this.y,
              direction = this.direction;
            if (isClockwise) {
              this.direction = (this.direction + 3) % 4;
            } else {
              this.direction = (this.direction + 1) % 4;
            }
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x + 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x - 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x;
            this.y = y;
            this.direction = direction;
          }
        }
        class BlockT extends Block {
          constructor(board, x, y) {
            super(board, x, y);
            this.type = "T";
            this.color = colorsTheme.t;
        
            this.direction = 0; // true or false horizontal or vertical
          }
          getNodes() {
            switch (this.direction) {
              // 0 0 0
              // 0 * 0
              // 1 1 1
              case 0:
                return [
                  new Node(this.x, this.y, this.type),
                  new Node(this.x + 1, this.y + 1, this.type),
                  new Node(this.x, this.y + 1, this.type),
                  new Node(this.x - 1, this.y + 1, this.type)
                ];
              // 0 1 0
              // 0 * 1
              // 0 1 0
              case 1:
                return [
                  new Node(this.x, this.y, this.type),
                  new Node(this.x + 1, this.y, this.type),
                  new Node(this.x, this.y + 1, this.type),
                  new Node(this.x, this.y - 1, this.type)
                ];
              // 0 0 0
              // 1 * 1
              // 0 1 0
              case 2:
                return [
                  new Node(this.x, this.y, this.type),
                  new Node(this.x - 1, this.y, this.type),
                  new Node(this.x + 1, this.y, this.type),
                  new Node(this.x, this.y + 1, this.type)
                ];
              // 0 1 0
              // 1 * 0
              // 0 1 0
              case 3:
                return [
                  new Node(this.x - 1, this.y, this.type),
                  new Node(this.x, this.y, this.type),
                  new Node(this.x, this.y - 1, this.type),
                  new Node(this.x, this.y + 1, this.type)
                ];
            }
          }
          turn(isClockwise) {
            let x = this.x,
              y = this.y,
              direction = this.direction;
            if (isClockwise) {
              this.direction = (this.direction + 3) % 4;
            } else {
              this.direction = (this.direction + 1) % 4;
            }
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x + 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x - 1;
            if (this.board.isEmpty(this.getNodes())) {
              return;
            }
            this.x = x;
            this.y = y;
            this.direction = direction;
          }
        }
        class Controller {
          constructor() {
            this.config = {
              keys: {
                'ArrowLeft': 'left',
                'ArrowRight':'right',
                'ArrowUp':'rotate',
                'ArrowDown':'down',
                'KeyA':'left',
                'KeyD':'right',
                'KeyW':'rotate',
                'KeyS':'down'
              },
              keyFirstDelay: 70
            };
            this.keys = [];
            this.board = new Board(config, cvs);
            this.painter = new Painter(config, cvs, this.board);
            // board
            this.keyDelayIds = { left: {}, right: {}, down: {} };
            this.dropDelay = 1000;
            this.dropIntervalId = 0;
            this.paused = false;
          }
          start() {
            this.initConfig();
            this.initKeys();
            this.frameLoop();
            this.board.randomBlock();
            this.board.addBlock();
            this.startDrop();
          }
        
          frameLoop() {
            requestAnimationFrame(() => {
              this.board.ridLine();
              this.painter.draw();
              this.frameLoop();
            });
          }
          startDrop() {
            this.dropIntervalId = setInterval(() => {
              if (this.board.moveBlock(direction.down)) {
                this.speedUp();
                window.clearInterval(this.dropIntervalId);
                this.startDrop();
              }
            }, this.dropDelay);
          }
          speedUp() {
            this.dropDelay = 1000 - this.board.level * 100;
            if (this.dropDelay < 250) {
              this.dropDelay = 250;
            }
          }
        
          initConfig() {
              config.fontStyle = `${config.cubeSize * config.fontSize}px  ${config.font}`;
          }
          initKeys() {
            window.onkeydown = e => {
              switch (this.config.keys[e.code]) {
                case 'left':
                  if (this.keys.left) {
                    return;
                  }
                  this.keys.left = true;
                  this.board.moveBlock(direction.left);
                  this.keyDelayIds.left.timeoutId = setTimeout(() => {
                    if (this.keys.left) {
                      this.keyDelayIds.left.intervalId = setInterval(() => {
                        this.board.moveBlock(direction.left);
                      }, 45);
                    }
                  }, this.config.keyFirstDelay);
                  break;
                case 'right':
                  if (this.keys.right) {
                    return;
                  }
                  this.keys.right = true;
                  this.board.moveBlock(direction.right);
                  this.keyDelayIds.right.timeoutId = setTimeout(() => {
                    if (this.keys.right) {
                      this.keyDelayIds.right.intervalId = setInterval(() => {
                        this.board.moveBlock(direction.right);
                      }, 45);
                    }
                  }, this.config.keyFirstDelay);
                  break;
                case 'rotate':
                  this.board.block.turn();
                  break;
                case 'down':
                  if (this.keys.down) {
                    return;
                  }
                  this.keys.down = true;
                  this.keyDelayIds.down.intervalId = setInterval(() => {
                    this.board.moveBlock(direction.down);
                  }, 45);
                  break;
              }
            };
        
            window.onkeyup = e => {
              log(e);
              switch (this.config.keys[e.code]) {
                case 'left':
                  this.keys.left = false;
                  window.clearInterval(this.keyDelayIds.left.timeoutId);
                  window.clearInterval(this.keyDelayIds.left.intervalId);
                  break;
                case 'right':
                  this.keys.right = false;
                  window.clearInterval(this.keyDelayIds.right.timeoutId);
                  window.clearInterval(this.keyDelayIds.right.intervalId);
                  break;
                case 'down':
                  this.keys.down = false;
                  window.clearInterval(this.keyDelayIds.down.intervalId);
                  break;
              }
            };
          }
        }
        new Controller().start();
        
        const html = document.getElementsByTagName("html")[0];
        
        document.getElementById("theme").onchange = (e) => {
          if(e.target.checked){
            colorsTheme = config.colors.light;
            html.style.backgroundColor=colorsTheme.bg;
            document.body.style.backgroundColor=colorsTheme.bg;
            ca.style.backgroundColor = colorsTheme.canvasBg;
            ca.style.borderColor = colorsTheme.border;
          } else {
            colorsTheme = config.colors.dark;
            html.style.backgroundColor=colorsTheme.bg;
            document.body.style.backgroundColor=colorsTheme.bg;
            ca.style.backgroundColor = colorsTheme.canvasBg;    
            ca.style.borderColor = colorsTheme.border;
          }
        }
  
    </script>
</body>
</html>